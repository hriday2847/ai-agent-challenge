#!/usr/bin/env python3
"""
Demo version of the AI Agent - works without API keys for demonstration
"""

import os
import sys
import json
import argparse
from pathlib import Path
from typing import Dict, List, Any, Optional
import pandas as pd
import re
from datetime import datetime
from dataclasses import dataclass, field

# Rich console for better output
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

console = Console()

@dataclass
class AgentState:
    """State management for the agent loop."""
    target_bank: str
    pdf_path: str
    csv_path: str
    attempt: int = 1
    max_attempts: int = 3
    parser_code: str = ""
    test_results: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    success: bool = False

class DemoParserGenerator:
    """Demo agent class that generates parsers without LLM calls."""
    
    def __init__(self):
        console.print("[yellow]Running in DEMO mode - no API keys required[/yellow]")
    
    def analyze_pdf_structure(self, pdf_path: str) -> str:
        """Analyze PDF structure and extract text content."""
        try:
            if pdf_path.endswith('.txt'):
                with open(pdf_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            else:
                content = "PDF content would be extracted here"
            
            return content
        except Exception as e:
            return f"Error reading PDF: {str(e)}"
    
    def analyze_csv_schema(self, csv_path: str) -> Dict[str, Any]:
        """Analyze CSV schema and structure."""
        try:
            df = pd.read_csv(csv_path)
            schema = {
                "columns": list(df.columns),
                "dtypes": df.dtypes.to_dict(),
                "sample_data": df.head(3).to_dict('records'),
                "total_rows": len(df)
            }
            return schema
        except Exception as e:
            return {"error": str(e)}
    
    def generate_parser_code(self, pdf_content: str, csv_schema: Dict[str, Any], bank_name: str) -> str:
        """Generate parser code using predefined templates."""
        
        # Analyze the PDF content to understand the format
        lines = pdf_content.split('\n')
        date_format = "DD/MM/YYYY" if "/" in pdf_content else "YYYY-MM-DD"
        
        # Generate parser based on schema
        columns = csv_schema.get("columns", [])
        
        # Create a more sophisticated parser template
        parser_code = f'''"""
Generated parser for {bank_name} bank statements.
Generated by AI Agent on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""

import pandas as pd
import re
from datetime import datetime
from typing import List, Dict, Any

def parse(pdf_path: str) -> pd.DataFrame:
    """
    Parse {bank_name} bank statement PDF and return DataFrame.
    
    Args:
        pdf_path (str): Path to the PDF file
        
    Returns:
        pd.DataFrame: Parsed transaction data with columns: {columns}
    """
    try:
        # Read PDF content (in demo, we read text file)
        if pdf_path.endswith('.txt'):
            with open(pdf_path, 'r', encoding='utf-8') as f:
                content = f.read()
        else:
            # In real implementation, use pdfplumber or PyPDF2
            content = "PDF content would be extracted here"
        
        # Parse transactions
        transactions = []
        
        # Split content into lines
        lines = content.split('\\n')
        
        # Find transaction lines (skip headers)
        for line in lines:
            # Skip header lines and empty lines
            if not line.strip() or 'Date' in line and 'Description' in line or '{bank_name.upper()} BANK' in line or 'Account Number' in line:
                continue
                
            # Skip summary lines
            if 'Total' in line or 'Closing Balance' in line:
                continue
            
            # Parse transaction line - format: Date Description Debit Credit Balance
            parts = line.split()
            if len(parts) >= 4:
                try:
                    # Extract date (first part)
                    date_str = parts[0]
                    date_obj = datetime.strptime(date_str, "%d/%m/%Y")
                    date = date_obj.strftime("%Y-%m-%d")
                    
                    # Find the amounts in the line
                    amounts = []
                    desc_parts = []
                    
                    for part in parts[1:]:
                        if re.match(r'^[\\d,]+\.[\\d]{{2}}$', part):
                            amounts.append(float(part.replace(',', '')))
                        else:
                            desc_parts.append(part)
                    
                    description = ' '.join(desc_parts)
                    
                    # Parse based on the format: Date Description Debit Credit Balance
                    # For debit transactions: Date Description Debit "" Balance
                    # For credit transactions: Date Description "" Credit Balance
                    # For opening balance: Date Description "" "" Balance
                    
                    debit = None
                    credit = None
                    balance = None
                    
                    if len(amounts) == 1:
                        # Only one amount - opening balance
                        balance = amounts[0]
                    elif len(amounts) == 2:
                        # Two amounts - either debit+balance or credit+balance
                        # Check if it's a debit transaction
                        if any(word in description.lower() for word in ['withdrawal', 'purchase', 'payment', 'debit', 'shopping']):
                            debit = amounts[0]
                            balance = amounts[1]
                        else:
                            credit = amounts[0]
                            balance = amounts[1]
                    
                    # Create transaction record
                    transaction = {{
                        'Date': date,
                        'Description': description,
                        'Debit': debit if debit is not None else None,
                        'Credit': credit if credit is not None else None,
                        'Balance': balance if balance is not None else None
                    }}
                    
                    transactions.append(transaction)
                    
                except (ValueError, IndexError):
                    continue
        
        # Create DataFrame
        df = pd.DataFrame(transactions)
        
        # Ensure all required columns exist
        required_columns = {columns}
        for col in required_columns:
            if col not in df.columns:
                df[col] = None
        
        # Reorder columns to match expected schema
        df = df[required_columns]
        
        return df
        
    except Exception as e:
        print(f"Error parsing PDF: {{e}}")
        return pd.DataFrame(columns={columns})

if __name__ == "__main__":
    # Test the parser
    result = parse("data/{bank_name}/{bank_name}_sample.pdf")
    print(result)
'''
        
        return parser_code
    
    def test_parser(self, parser_code: str, pdf_path: str, csv_path: str) -> Dict[str, Any]:
        """Test the generated parser against the expected CSV."""
        try:
            # Create temporary parser file
            parser_file = f"temp_parser_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
            
            with open(parser_file, 'w') as f:
                f.write(parser_code)
            
            # Import and test the parser
            import importlib.util
            spec = importlib.util.spec_from_file_location("temp_parser", parser_file)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Run parser
            result_df = module.parse(pdf_path)
            expected_df = pd.read_csv(csv_path)
            
            # Compare results
            is_equal = result_df.equals(expected_df)
            
            # Cleanup
            os.remove(parser_file)
            
            return {
                "success": is_equal,
                "result_shape": result_df.shape,
                "expected_shape": expected_df.shape,
                "columns_match": list(result_df.columns) == list(expected_df.columns),
                "data_match": is_equal
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def run_agent_loop(self, state: AgentState) -> AgentState:
        """Main agent loop: plan → generate → test → fix."""
        
        console.print(Panel(f"[bold blue]Starting Demo Agent Loop for {state.target_bank}[/bold blue]"))
        
        while state.attempt <= state.max_attempts and not state.success:
            console.print(f"\n[bold yellow]Attempt {state.attempt}/{state.max_attempts}[/bold yellow]")
            
            # Step 1: Analyze inputs
            with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}")) as progress:
                task = progress.add_task("Analyzing PDF structure...", total=None)
                pdf_content = self.analyze_pdf_structure(state.pdf_path)
                progress.update(task, description="Analyzing CSV schema...")
                csv_schema = self.analyze_csv_schema(state.csv_path)
            
            # Step 2: Generate parser code
            console.print("[green]Generating parser code...[/green]")
            state.parser_code = self.generate_parser_code(pdf_content, csv_schema, state.target_bank)
            
            # Step 3: Test parser
            console.print("[green]Testing parser...[/green]")
            test_result = self.test_parser(state.parser_code, state.pdf_path, state.csv_path)
            state.test_results.append(test_result)
            
            if test_result.get("success", False):
                state.success = True
                console.print("[bold green]Parser generated successfully![/bold green]")
                break
            else:
                console.print(f"[red]Test failed: {test_result.get('error', 'Unknown error')}[/red]")
                state.attempt += 1
        
        return state
    
    def save_parser(self, parser_code: str, bank_name: str):
        """Save the generated parser to custom_parsers directory."""
        parser_file = f"custom_parsers/{bank_name}_parser.py"
        
        # Ensure directory exists
        os.makedirs("custom_parsers", exist_ok=True)
        
        with open(parser_file, 'w') as f:
            f.write(parser_code)
        
        console.print(f"[green]Parser saved to: {parser_file}[/green]")
        return parser_file

def main():
    """Main CLI entry point for demo."""
    parser = argparse.ArgumentParser(description="Demo AI Agent for Bank Statement Parser Generation")
    parser.add_argument("--target", required=True, help="Target bank name (e.g., icici)")
    parser.add_argument("--pdf", help="Path to PDF file (default: data/{target}/{target}_sample.pdf)")
    parser.add_argument("--csv", help="Path to CSV file (default: data/{target}/{target}_sample.csv)")
    
    args = parser.parse_args()
    
    # Set default paths
    if not args.pdf:
        args.pdf = f"data/{args.target}/{args.target}_sample.pdf"
    if not args.csv:
        args.csv = f"data/{args.target}/icic_sample.csv"
    
    # Handle text file for demo
    if not os.path.exists(args.pdf):
        # Try different variations
        variations = [
            args.pdf + ".txt",
            f"data/{args.target}/icic_sample.pdf.txt",
            f"data/{args.target}/{args.target}_sample.pdf.txt"
        ]
        for var in variations:
            if os.path.exists(var):
                args.pdf = var
                break
    
    # Validate inputs
    if not os.path.exists(args.pdf):
        console.print(f"[red]PDF file not found: {args.pdf}[/red]")
        sys.exit(1)
    
    if not os.path.exists(args.csv):
        console.print(f"[red]CSV file not found: {args.csv}[/red]")
        sys.exit(1)
    
    # Initialize demo agent
    agent = DemoParserGenerator()
    
    # Create initial state
    state = AgentState(
        target_bank=args.target,
        pdf_path=args.pdf,
        csv_path=args.csv
    )
    
    # Run agent loop
    final_state = agent.run_agent_loop(state)
    
    if final_state.success:
        # Save parser
        parser_file = agent.save_parser(final_state.parser_code, args.target)
        
        # Generate test file
        test_file = f"tests/test_{args.target}_parser.py"
        os.makedirs("tests", exist_ok=True)
        
        test_code = f'''import pytest
import pandas as pd
from custom_parsers.{args.target}_parser import parse

def test_{args.target}_parser():
    """Test the generated {args.target} parser."""
    pdf_path = "{args.pdf}"
    expected_csv = "{args.csv}"
    
    # Run parser
    result_df = parse(pdf_path)
    expected_df = pd.read_csv(expected_csv)
    
    # Assert equality
    assert result_df.equals(expected_df), f"Parser output does not match expected CSV"
    print("Parser test passed!")

if __name__ == "__main__":
    test_{args.target}_parser()
'''
        
        with open(test_file, 'w') as f:
            f.write(test_code)
        
        console.print(f"[green]Test file generated: {test_file}[/green]")
        console.print("\n[bold green]Demo Agent completed successfully![/bold green]")
        console.print(f"Run: pytest {test_file} -v")
        
    else:
        console.print("[red]❌ Demo Agent failed to generate working parser after all attempts[/red]")
        sys.exit(1)

if __name__ == "__main__":
    main()
